---
title: 'Prisma Client API Reference'
metaTitle: 'Prisma Client API (Reference)'
metaDescription: 'API reference documentation for Prisma Client.'
tocDepth: 2
toc: true
---

<TopBlock>

The Prisma Client API reference documentation is based on the following schema:

```prisma
model User {
  id           Int       @id @default(autoincrement())
  name         String?
  email        String    @unique
  profileViews Int       @default(0)
  role         Role      @default(USER)
  coinflips    Boolean[]
  posts        Post[]
}

model Post {
  id         Int     @id @default(autoincrement())
  title      String
  published  Boolean @default(true)
  author     User    @relation(fields:  [authorId], references: [id])
  authorId   Int
  comments   Json
  views      Int     @default(0)
  likes      Int     @default(0)
}

enum Role {
  USER
  ADMIN
}
```

All example generated types (such as `UserSelect` and `UserWhereUniqueInput`) are based on the `User` model.

</TopBlock>

## Model queries

### <inlinecode>findOne</inlinecode>

`findOne` query lets you retrieve a single database record:

- By _ID_
- By a _unique_ attribute

#### Options

| Name      | Example type (`User`)                   | Required | Description                                                                      |
| --------- | --------------------------------------- | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput`                  | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | [`XOR<UserSelect, null>`](#reference-1) | No       | Specifies which properties to include on the returned object.                    |
| `include` | `XOR<UserInclude, null>`                | No       | Specifies which relations should be eagerly loaded on the returned object.       |

#### Return type

| Return type               | Example                    | Description                                                                      |
| ------------------------- | -------------------------- | -------------------------------------------------------------------------------- |
| Javascript object (typed) | `User`                     | Specifies which properties to include on the returned object.                    |
| Javascript object (plain) | `{ title: "Hello world" }` | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `null`                    | `null`                     | Record not found                                                                 |

#### Reference

`findOne` takes an object with one of the following types as input:

```ts file=index.d.ts
export type FindOneUserArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

#### Examples

##### Retrieve the `User` record with an `id` of `42`

```ts
const result = await prisma.user.findOne({
  where: {
    id: 42,
  },
})
```

##### Retrieve the `User` record with an `email` of `alice@prisma.io`

```ts
const result = await prisma.user.findOne({
  where: {
    email: 'alice@prisma.io',
  },
})
```

##### Retrieve the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@unique`)

<details><summary>Expand for example User model with a @@unique block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

</details>

```ts
const result = await prisma.user.findOne({
  where: {
    fullname: {
      // name property of @@unique attribute - default is firstname_lastname
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

##### Retrieve the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@id`)

<details><summary>Expand for example User model with an @@id block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

</details>

```ts
const result = await prisma.user.findOne({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

### <inlinecode>findFirst</inlinecode>

`findFirst` returns the first record in a list that matches your criteria.

#### Options

| Name       | Example type (`User`)                                        | Required | Description                                                                                                                                                                                                                                |
| ---------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `distinct` | `Enumerable<UserDistinct`<br />`FieldEnum>`                  | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                                                  |
| `where`    | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                                                       |
| `cursor`   | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                                                       |
| `orderBy`  | `XOR<Enumerable<User`<br />`OrderByInput>,UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                                                          |
| `include`  | `XOR<UserInclude, null>`                                     | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                 |
| `select`   | `XOR<UserSelect, null>`                                      | No       | Specifies which properties to include on the returned object.                                                                                                                                                                              |
| `skip`     | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                                                  |
| `take`     | `number`                                                     | No       | Specifies how many objects should be returned in the list. When used with `findFirst`, `take` is implicitly `1` or `-1`. `findFirst` is only affected by whether the value is positive or negative - any negative value reverses the list. |

#### Return type

| Return type               | Example                    | Description                                                                      |
| ------------------------- | -------------------------- | -------------------------------------------------------------------------------- |
| Javascript object (typed) | `User`                     | Specifies which properties to include on the returned object.                    |
| Javascript object (plain) | `{ title: "Hello world" }` | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `null`                    | `null`                     | Record not found                                                                 |

#### Reference

```ts file=index.d.ts
export type FindFirstUserArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Remarks

- `findFirst` calls `findMany` behind the scenes and accepts the same query options.
- Passing in a negative `take` value when you use a `findFirst` query reverses the order of the list.

#### Examples

##### Retrieve the first `User` record where the `name` is `Alice`

```ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

##### Retrieve the first `Post` record where the `title` starts with `A test`, reverse the list with `take`

```ts file="script.ts"
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({})

async function mainAsync() {
  const a = await prisma.post.create({
    data: {
      title: 'A test 1',
    },
  })

  const b = await prisma.post.create({
    data: {
      title: 'A test 2',
    },
  })

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: 'A test',
      },
    },
    orderBy: {
      title: 'asc',
    },
    take: -1, // Reverse the list
  })

  console.log(c)
}

mainAsync()
```

See [filtering documentation](filtering#filter-on-related-records) for advanced examples.

### <inlinecode>findMany</inlinecode>

`findMany` returns a list of records.

#### Options

| Name       | Type                                                          | Required | Description                                                                                                                                                                                     |
| ---------- | ------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                            |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                               |
| `skip`     | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                       |
| `cursor`   | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                            |
| `take`     | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (+ve value) or _end_ (-ve value) **either** of the list **or** from the `cursor` position if mentioned) |
| `select`   | `XOR<PostSelect, null>`                                       | No       | Specifies which properties to include on the returned object.                                                                                                                                   |
| `include`  | `XOR<PostInclude, null>`                                      | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                      |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                       |

#### Return type

| Return type                     | Example                      | Description                                                                             |
| ------------------------------- | ---------------------------- | --------------------------------------------------------------------------------------- |
| Javascript array object (typed) | `User[]`                     |                                                                                         |
| Javascript array object (plain) | `[{ title: "Hello world" }]` | Returned if you use `select` or `include` to customize which fields should be returned. |
| Empty array                     | `[]`                         | No matching records found.                                                              |

#### Reference

`findMany` accepts the following input type:

```ts file=index.d.ts
export type FindManyUserArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

**Retrieve all `User` records where the `name` is `Alice`**:

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

See [filtering documentation](filtering#filter-on-related-records) for advanced examples.

### <inlinecode>create</inlinecode>

`create` creates a new database record.

#### Options

| Name      | Type                                                     | Required | Description                                                                                                                                                                                                                                                                   |
| --------- | -------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `XOR<UserCreateInput,` <br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `select`  | `XOR<UserSelect, null>`                                  | No       | Specifies which properties to include on the returned object.                                                                                                                                                                                                                 |
| `include` | `XOR<UserInclude, null>`                                 | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                                                    |

#### Return type

| Return type                     | Example                        | Description                                                                             |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         |                                                                                         |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Returned if you use `select` or `include` to customize which fields should be returned. |

#### Remarks

#### Reference

`create` accepts the following input type:

```ts file=index.d.ts
export type UserCreateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserCreateInput, UserUncheckedCreateInput>
}
```

#### Examples

##### Create a single new record with the only required field `email`

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

##### Create multiple new records

Prisma Client does not yet support batch inserts at a database level. Follow [issue #332 on GitHub](https://github.com/prisma/prisma-client-js/issues/332) for updates.

The following example results in **two** `INSERT` statements:

<CodeWithResult expanded={true}>

<Cmd>

```ts
import { PrismaClient, UserCreateInput } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  let users: UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  await Promise.all(
    users.map(async user => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</Cmd>

<CmdResult>

```sql
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query COMMIT
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
```

</CmdResult>

</CodeWithResult>

> **Tip**: Consider using the raw for bulk inserting large numbers of records.

##### Create multiple new records in a transaction

TODO

```ts
transaction
```

##### Nested `create` queries

You can also perform nested writes, such as:

- Create a `User` and one or more connected `Post` records at the same time (see [example](relation-queries#create-a-new-user-record-with-two-new-post-records))
- Create a `Post` and connect it to an existing user, or create a new `User` record (see [example](relation-queries#create-a-new-post-record-and-connect-it-to-an-existing-user-record-or-create-a-new-user))

### <inlinecode>update</inlinecode>

`update` updates an existing database record.

#### Options

| Name      | Type                                                   | Required | Description                                                                                                                                                                               |
| --------- | ------------------------------------------------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `XOR<UserUpdateInput`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional. |
| `where`   | `UserWhereUniqueInput`                                 | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected.                                                                                                          |
| `select`  | `XOR<UserSelect, null>`                                | No       | Specifies which properties to include on the returned object.                                                                                                                             |
| `include` | `XOR<UserInclude, null>`                               | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                |

#### Return type

| Return type                     | Example                        | Description                                                                             |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         |                                                                                         |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Returned if you use `select` or `include` to customize which fields should be returned. |
| `RecordNotFound` exception      |                                |

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

#### Reference

```ts file=index.d.ts
export type UserUpdateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  where: UserWhereUniqueInput
}
```

#### Examples

##### Update the `email` of the `User` record with `id` of `1` to `alice@prisma.io`

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

##### Nested `update` queries

You can also perform nested writes during an update, such as:

- Update a `User` and update one or more connected `Post` records at the same time (see [example](relation-queries#update-an-existing-user-record-by-updating-two-post-records-its-connected-to))
- Update a `User` and connect it to one or more existing `Post` records, or add new `Post` records (see [example](relation-queries#update-an-existing-user-record-by-connect-it-to-two-existing-post-records-or-creating-two-new-post-records))

### <inlinecode>upsert</inlinecode>

`upsert` updates an existing _or_ creates a new database record.

#### Options

| Name      | Type                                                    | Required | Description                                                                                                                                                                                                                                                                |
| --------- | ------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`  | `XOR<UserCreateInput,`<br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `update`  | `XOR<UserUpdateInput,`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                                                                  |
| `where`   | `UserWhereUniqueInput`                                  | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected.                                                                                                                                                                                           |
| `select`  | `XOR<UserSelect, null>`                                 | No       | Specifies which properties to include on the returned object.                                                                                                                                                                                                              |
| `include` | `XOR<UserInclude, null>`                                | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                                                 |

#### Return type

| Return type                     | Example                        | Description                                                                             |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         |                                                                                         |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Returned if you use `select` or `include` to customize which fields should be returned. |

#### Reference

```ts file=index.d.ts
export type UserUpsertArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
  create: XOR<UserCreateInput, UserUncheckedCreateInput>
  update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
}
```

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

#### Examples

##### Update (if exists) or create a new `User` record with an `email` of `alice@prisma.io`

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```

### <inlinecode>delete</inlinecode>

`delete` deletes an existing database record. Even though the record is being deleted, `delete` still returns the object that was deleted.

#### Options

| Name      | Type                     | Required | Description                                                                      |
| --------- | ------------------------ | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput`   | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | `XOR<UserSelect, null>`  | No       | Specifies which properties to include on the returned object.                    |
| `include` | `XOR<UserInclude, null>` | No       | Specifies which relations should be eagerly loaded on the returned object.       |

#### Reference

```ts file=index.d.ts
export type UserDeleteArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
}
```

#### Return type

| Return type                     | Example                        | Description                                                                                                                           |
| ------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         | The `User` record that was deleted.                                                                                                   |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Data from the `User` record that was deleted. Returned if you use `select` or `include` to customize which fields should be returned. |
| `RecordNotFound` exception      |                                | Returned if record does not exist.                                                                                                    |

#### Remarks

- To delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)

#### Examples

##### Delete the `User` record with an `id` of `1`

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

##### Delete the `User` record where `email` equals `else@prisma.io`

<CodeWithResult expanded="{true}">

<Cmd>

```ts
const deleteUser = await prisma.user.delete({
  where: {
    email: 'elsa@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</Cmd>

<CmdResult>

```json
{ "email": "elsa@prisma.io", "name": "Elsa" }
```

</CmdResult>

</CodeWithResult>

### <inlinecode>updateMany</inlinecode>

`updateMany` updates a batch of existing database records in bulk and returns the number of updated records.

#### Options

| Name    | Type                                                                    | Required | Description                                                                                                                                                                                         |
| ------- | ----------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`  | `XOR<UserUpdateManyMutationInput,`<br />`UserUncheckedUpdateManyInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`. |
| `where` | `UserWhereInput`                                                        | No       | Wraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.                                                         |

#### Reference

```ts file=index.d.ts
export type UserUpdateManyArgs = {
  data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
  where?: UserWhereInput
}
```

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Examples

##### Update all `User` records where the `name` is `Alice` to `ALICE`

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

##### Update all `User` records where the `email` contains `prisma.io` and at least one related `Post` has more than 10 likes

```ts
const deleteUser = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
    posts: {
      some: {
        likes: {
          gt: 10,
        },
      },
    },
  },
  data: {
    role: 'USER',
  },
})
```

### <inlinecode>deleteMany</inlinecode>

#### Options

| Name    | Type             | Required | Description                                                                  |
| ------- | ---------------- | -------- | ---------------------------------------------------------------------------- |
| `where` | `UserWhereInput` | No       | Wraps _all_ fields of a model so that the list can be filtered by any field. |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Reference

```ts
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}
```

#### Examples

##### Delete all `User` records where the `name` is `Alice`

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>count</inlinecode>

#### Options

| Name       | Type                                                          | Required | Description                                                                                                                                                                                     |
| ---------- | ------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                            |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                               |
| `skip`     | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                       |
| `cursor`   | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                            |
| `take`     | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (+ve value) or _end_ (-ve value) **either** of the list **or** from the `cursor` position if mentioned) |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                       |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `number` | `29` | The count of records. |


#### Reference

```ts file=index.d.ts
export type FindManyUserArgs = {
  // select and include are excludeld
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

##### Count all `User` records:

```ts
const result = await prisma.user.count()
```

##### Count all `User` records with at least one published `Post`

```ts
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

### <inlinecode>aggregate</inlinecode>

## Nested queries

### <inlinecode>connect</inlinecode>

### <inlinecode>connectOrCreate</inlinecode>

### <inlinecode>disconnect</inlinecode>

## Filter conditions and operators

`where`

### <inlinecode>equals</inlinecode>

Value equals `n`.

#### Examples

### <inlinecode>not</inlinecode>

Vaulue does not equal `n`.

### <inlinecode>in</inlinecode>

### <inlinecode>notIn</inlinecode>

### <inlinecode>lt</inlinecode>

### <inlinecode>lte</inlinecode>

### <inlinecode>gt</inlinecode>

### <inlinecode>mode</inlinecode>

#### Examples

##### Retrieve all `Post` records where `date_created` is greater than March 19th, 2020

```js
const result = await prisma.post.findMany({
  where: {
    date_created: {
      gte: new Date('2020-03-19T14:21:00+0200') /* Includes time offset for UTC */,
    },
  },
})
```

### <inlinecode>gte</inlinecode>

### <inlinecode>contains</inlinecode>

#### Examples

##### Retrieve all `Post` records where `content` contains `databases`

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```


### <inlinecode>startsWith</inlinecode>

#### Examples

##### Retrieve all `Post` records where `title` starts with `Pr` (such as `Prisma`)

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      startsWith: 'Pr',
    },
  },
})
```

### <inlinecode>endsWith</inlinecode>

#### Retrieve all `User` records where `email` ends with `prisma.io`

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```


Prisma Client supports the following filter conditions:

| Operator     | Supported types                                                                                              | Notes                                                                |
| ------------ | ------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------- |
| `equals`     | `string`<br />`number`<br />`boolean`<br />`Date`<br />`[enum]`<br />`null`                                  | Value equals.                                                        |
| `not`        | `string`<br />`number`<br />`boolean`<br />`Date`<br />`[enum]`<br />`null`                                  | Value does not equal.                                                |
| `in`         | `Enumerable<string>`<br />`Enumerable<number>`<br />`Enumerable<Date>`<br />`Enumerable<[enum]>`<br />`null` | Value exists in list.                                                |
| `notIn`      | `Enumerable<string>`<br />`Enumerable<number>`<br />`Enumerable<Date>`<br />`Enumerable<[enum]>`<br />`null` | Value does not exist in list.                                        |
| `lt`         | `string`<br />`number`<br />`Date`<br />`null`                                                               | Value is less than X.                                                |
| `lte`        | `string`<br />`number`<br />`Date`<br />`null`                                                               | Value is less than or equal to X.                                    |
| `gt`         | `string`<br />`number`<br />`Date`<br />`null`                                                               | Value is greater than X.                                             |
| `gte`        | `string`<br />`number` <br />`Date`<br />`null`                                                              | Value is greater than or equal to                                    |
| `contains`   | `string`<br />`null`                                                                                         | Value contains. Does not support wildcards - for example, `b[a-c]d`. |
| `startsWith` | `string`<br />`null`                                                                                         | Value starts with.                                                   |
| `endsWith`   | `string`<br />`null`                                                                                         | Value ends with.                                                     |

### <inlinecode>AND</inlinecode>

### <inlinecode>OR</inlinecode>


### <inlinecode>NOT</inlinecode>

You can combine multiple filter conditions with the following operators:

| Operator | Notes                                                                                                                                                     |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `AND`    | All conditions must return`true`. Alternatively, pass a list of objects into the `where` clause - the `AND` operator is [not required](filtering#no-and). |
| `NOT`    | All conditions must return `false`.                                                                                                                       |
| `OR`     | One or more conditions must return `true`.                                                                                                                |

Prisma Client offers the following operators for filtering on one-to-many relationships:



### <inlinecode>some</inlinecode>

Returns all records where **one or more** ("some") _related_ records match filtering criteria.

#### Reference

```ts
export type PostFilter = {
  every?: PostWhereInput | null
|  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```


### <inlinecode>every</inlinecode>

Returns all records where **all** ("every") _related_ records match filtering criteria. 

#### Reference

```ts
export type PostFilter = {
|  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```


### <inlinecode>none</inlinecode>

Returns all records where **zero** _related_ records match filtering criteria.

#### Reference

```ts
export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
|  none?: PostWhereInput | null
}
```


### Examples




#### Count all `Post` records where `content` contains `databases`

```js
const result = await prisma.post.count({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```

#### Retrieve all `Post` records where the `content` field contains `Prisma` and `published` is `false`

```js
const result = await prisma.post.findMany({
  where: {
    AND: [
      {
        content: {
          contains: 'Prisma',
        },
      },
      {
        published: {
          equals: false,
        },
      },
    ],
  },
})
```

The following format returns the same results as above **without** the `AND` operator:

<a id="#no-and"></a>

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'Prisma',
    },
    published: {
      equals: false,
    },
  },
})
```

> **Note**: `OR` and `NOT` require an array.

#### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
  },
})
```

#### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

#### Retrieve all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

You can [enable logging](logging) to debug complex queries:

```js
const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
  ],
})

prisma.$on('query', e => {
  e.query, console.log(e)
})
```

#### Retrieve all `User` records where _all_ posts are published and a least one related `Post` mentions `Prisma`

```js
  const result = await prisma.user.findMany({
    where: {
      post: {
          every: {
            published: true
          }
        some: {
          content: {
            contains: "Prisma"
          }
        }
      }
    }
  }
```

#### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`, and the related `User` record' email address does not contain `sarah`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
    user: {
      NOT: {
        email: {
          contains: 'sarah',
        },
      },
    },
  },
  include: {
    user: true,
  },
})
```

## Atomic number operations

Atomic operations on update is available for number field types (`Float` and `Int`). This feature allows you to update a field based on its **current** value (such as _subtracting_ or _dividing_) without risking a race condition.

<details><summary>Overview: Race conditions</summary>

A race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:

| Client   | Operation           | Value  |
| :------- | :------------------ | :----- |
| Client 1 | **Get** field value | `21`   |
| Client 2 | **Get** field value | `21`   |
| Client 2 | **Set** field value | `22`   |
| Client 1 | **Set** field value | `22` ✘ |

The value _should_ be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:

| Client   | Operation                   | Value              |
| :------- | :-------------------------- | :----------------- |
| Client 1 | **Get and set** field value | `21` &rarr; `22`   |
| Client 2 | **Get and set** field value | `22` &rarr; `23` ✔ |

</details>

### Options

| Option      | Description                                                   |
| :---------- | :------------------------------------------------------------ |
| `increment` | Adds `n` to the current value.                                |
| `decrement` | Subtacts `n` from the current value.                          |
| `multiply`  | Multiplies the current value by `n`.                          |
| `divide`    | Divides the current value by `n`.                             |
| `set`       | Sets the current field value. Identical to `{ myField : n }`. |



### Reference 

```ts
export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

### Remarks

* You can only perform **one** atomic update per field, per query.

### Examples

#### Increment all `view` and `likes` fields of all `Post` records by `1`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1,
    },
    likes: {
      increment: 1,
    },
  },
})
```

#### Set all `count` fields of all `Post` records to `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0,
    },
  },
})
```

Can also be written as:

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  },
})
```

## Model query options

### <inlinecode>select</inlinecode>

Used by:

- `findFirst`
- `findOne`
- `findMany`
- `create`
- `update`
- `upsert`

#### Reference

```ts
export type UserSelect = {
  id?: boolean
  name?: boolean
  email?: boolean
  profileViews?: boolean
  role?: boolean
  coinflips?: boolean
  posts?: boolean | FindManyPostArgs
}
```

### <inlinecode>include</inlinecode>

## Client methods

- All client-level methods are prefixed by `$`

### <inlinecode>\$disconnect()</inlinecode>
