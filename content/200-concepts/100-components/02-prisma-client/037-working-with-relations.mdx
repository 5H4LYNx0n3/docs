---
title: 'Working with relations'
metaTitle: 'Working with relations (Reference)'
metaDescription: 'Prisma Client provides convenient queries for working with relations, such as a fluent API, nested writes (transactions), nested reads and relation filters.'
---

<TopBlock>

One of the main features of Prisma Client is its API for sending relation queries. Relation queries refer to queries that operate on a [relation](../prisma-schema/relations) between two or more models:

- Fluent API for traversing relations
- Nested writes with [transactional]() guarantees
- Nested reads (sometimes referred to as _eager loading_) via [`select`](field-selection#select) and [`include`](field-selection#include)
- Relation filters ([filters on related objects](filtering#filter-on-related-records))

</TopBlock>

## Read related records

See include and select + CRUD

## Connect and disconnect related records

## Filter on related records

## Fluent API

The fluent API lets you _fluently_ traverse the [relations](../prisma-schema/relations) of your models via function calls. Note that the _last_ function call determines the return type of the entire query (the respective type annotations are added in the code snippets below to make that explicit).

This query returns all `Post` records by a specific `User`:

```ts
const postsByUser: Post[] = await prisma.user
  .findOne({ where: { email: 'alice@prisma.io' } })
  .posts()
```

Note that this call is equivalent to this Prisma Client query:

```ts
const postsByUser = await prisma.post.findMany({
  where: { author: { email: 'alice@prisma.io' } },
})
```

The main difference between the two is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this [GitHub issue](https://github.com/prisma/prisma/issues/1984)).

This request returns all categories by a specific post:

```ts
const categoriesOfPost: Category[] = await prisma.post.findOne({ where: { id: 1 } }).categories()
```

Note that you can chain as many queries as you like. In this example, the chaining starts at `Profile` and goes over `User` to `Post`:

```ts
const posts: Post[] = await prisma.profile
    .findOne({ where: { id: 1 } })
    .user()
    .posts()
}
```

The only requirement for chaining is that the previous function call must return only a _single object_ (e.g. as returned by a `findOne` query or a "to-one relation" like `profile.user()`).

The following query is **not possible** because `findMany` does not return a single object but a _list_:

```ts
// This query is illegal
const posts = await prisma.user
    .findMany()
    .posts()
}
```

## Relation filters

A [relation filter](filtering#filter-on-related-records) is a filter operation that's applied to a related object of a model. Relation filter options can be passed to the last chained query in a fluent API call if it returns a [list](../prisma-schema/data-model#type-modifiers).

**Retrieve all `Post` records of a particular `User` record that start with "Hello"**

```ts
const posts: Post[] = await prisma.user
  .findOne({
    where: { email: 'ada@prisma.io' },
  })
  .posts({
    where: {
      title: { startsWith: 'Hello' },
    },
  })
```

Note that this query is _equivalent_ to the following one which is initiated via the `post` instead of the `user` field (in other words, it doesn't use the fluent API):

```ts
const posts = await prisma.post.findMany({
  where: {
    author: { email: 'bob@prisma.io' },
    title: { startsWith: 'Hello' },
  },
})
console.log(posts)
```

The main difference between the two is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this [GitHub issue](https://github.com/prisma/prisma/issues/1984)).

## Nested writes

Nested writes provide a way for writing relational data in your database. They further provide [transactional](transactions) guarantees for creating, updating or deleting data across multiple tables in a single Prisma Client query.

Nested writes can be nested arbitrarily deep.

Nested writes are available for [relation fields](../prisma-schema/relations#relation-fields) when using the model's `create` or `update` query. The following section shows the nested write options that are available per query.

### One-to-one relations

This section shows examples for nested writes on one-to-one relations. It uses the `User` ↔ `Profile` relation from the sample data model above. For illustration purposes, the `email` and `bio` fields have been added:


You can provide any [unique](../prisma-schema/data-model#defining-a-unique-field) or [ID](../prisma-schema/data-model#defining-an-id-field) property to the `connect` option, so in this case you could also provide the `id` field to identify the target `User` record:


### One-to-many relations

This section shows examples for nested writes on one-to-many relations. It uses the `User` ↔ `Post` relation from the sample data model above. For illustration purposes, the `email`, `title` and `published` fields have been added:

The following nested write options for `Post` are available in `prisma.post.update(...)` queries:

- `update`: Update an existing user by updating one or more of their existing posts
- `upsert`: Update an existing user by updating one or more of their existing posts or by creating one or more new posts
- `delete`: Update an existing user by deleting one or more of their existing posts
- `disconnect`: Update an existing by removing the connection(s) to one or more of their existing posts
- `set`: Update an existing user by replacing their existing posts with one or more existing posts
- `updateMany`: Update an existing user by updating one or more of their existing posts
- `deleteMany`: Update an existing user by deleting one or more of their existing posts

## Read related records (nested read)

With nested reads, you can modify the structures of the model objects that are returned by your Prisma Client queries by _including_ their relations. In ORM terminology, this is sometimes called _eager loading_.

You can load relations of your models with the [`include`](field-selection#include) and [`select`](field-selection#select) options which you can pass to _any_ Prisma Client query (except for the batch operations `updateMany` and `deleteMany`). `include` is more commonly used for relations, `select` is used for selecting specific fields.


**Retrieve deeply nested data by loading several levels of relations**

```ts
const users = await prisma.user.findMany({
  include: {
    posts: {
      include: {
        categories: {
          include: {
            posts: true,
          },
        },
      },
    },
  },
})
```
