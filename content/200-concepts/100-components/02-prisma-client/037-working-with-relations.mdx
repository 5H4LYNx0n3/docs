---
title: 'Working with relations'
metaTitle: 'Working with relations (Reference)'
metaDescription: 'Prisma Client provides convenient queries for working with relations, such as a fluent API, nested writes (transactions), nested reads and relation filters.'
tocDepth: 3
---

<TopBlock>



</TopBlock>

## Include related records

Related records are not returned by default. For example, to return a user _and_ that user's posts, you must explicitly `include` <span class="api"></span> posts. See [Select fields and include relations](select-and-include) for more information and examples.

## Add or remove related records

### Create a related record

You can create a record and one or more related records at the same time. The following query creates a `User` record and two related `Post` records:

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [{ title: 'How to make an omelette' }, { title: 'How to eat an omelette' }],
    },
  },
  include: {
    posts: true, // Include all posts in the returned object
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 29,
  name: 'Elsa Prisma',
  email: 'elsa@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 22,
      title: 'How to make an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 23,
      title: 'How to eat an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

</CmdResult>
</CodeWithResult>

### Connect an existing record

You can `connect` <span class="api"></span> an existing record to a new or existing user. The following query:

1. Connects an existing post (`id: 11`) to an existing user (`id: 9`)
2. Adds a new related post (`title: "My fist post title"`)

```ts file=script.ts
  const getUser = await prisma.user.update({
    where: {
      id: 9
    },
    data: {
      posts: {
|        connect: {
|          id: 11
|       },
        create: {
          title: "My new post title"
        }
      }
    }
  })
```

### Connect _or_ create a record

If a related record may or may not already exist, use `connectOrCreate` <span class="api"></span> to connect the related record:

- Connect a `User` with the email address `viola@prisma.io` _or_
- Create a new `User` with the email address `viola@prisma.io` if the user does not already exist

<CodeWithResult>
<Cmd>

```ts
  const createPost = await prisma.post.create({
      data: {
        title: "How to make croissants",
        author: {
          connectOrCreate: {
            where: {
              email: "viola@prisma.io"
            },
            create: {
              email: "viola@prisma.io",
              name: "Viola"
            }
          }
        }
      },
      include: {
        author: true
      }
  })
}
```

</Cmd>
<CmdResult>

```js
{
  id: 26,
  title: 'How to make croissants',
  published: true,
  authorId: 43,
  views: 0,
  likes: 0,
  author: {
    id: 43,
    name: 'Viola',
    email: 'viola@prisma.io',
    profileViews: 0,
    role: 'USER',
    coinflips: []
  }
}
```

</CmdResult>
</CodeWithResult>

### Disconnect a related record

To `disconnect` one out of a list of records (for example, a specific blog post) provide the ID or unique identifier of the record(s) to disconnect:

<CodeWithResult>
<Cmd>

```ts
  const updatePost = await prisma.user.update({
      where: {
        id: 16
      },
      data: {
        posts: {
          disconnect: {
            id: [ {12}, {19} ]
          }
        }
      },
      select: {
        posts: true
      }
  })
```

</Cmd>
<CmdResult>

```js
{
  id: 16,
  name: null,
  email: 'orla@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: []
}
```

</CmdResult>
</CodeWithResult>

To `disconnect` _one_ record (for example, a post's author), use `disconnect: true`:

<CodeWithResult>
<Cmd>

```ts
const updatePost = await prisma.post.update({
  where: {
    id: 23,
  },
  data: {
    author: {
      disconnect: true,
    },
  },
  include: {
    author: true,
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 23,
  title: 'How to eat an omelette',
  published: true,
  authorId: null,
  comments: null,
  views: 0,
  likes: 0,
  author: null
}
```

</CmdResult>
</CodeWithResult>

### Disconnect all related records

To `disconnect` <span class="api"></span> _all_ related records in a one-to-many relation (a user has many posts), `set` the relation to an empty list as shown:

<CodeWithResult>
<Cmd>

```ts

  const updateUser = await prisma.user.update({
      where: {
        id: 16
      },
      data: {
        posts: {
|         set: []
        }
      },
      include: {
        posts: true
      }
  })
```

</Cmd>
<CmdResult>

```js
{
  id: 16,
  name: null,
  email: 'orla@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: []
}
```

</CmdResult>
</CodeWithResult>

## Filtering

### Filter records by relation fields

Prisma Client provides the `some`, `every`, and `none` options to filter records by the properties of _related_ records. For example:

| Requirement                                                                       | Query option to use                 |
| --------------------------------------------------------------------------------- | ----------------------------------- |
| "I want a list of every `User` that has _at least one_ unpublished `Post` record" | `some` posts are unpublished        |
| "I want a list of every `User` that has _no_ unpublished `Post` records"          | `none` of the posts are unpublished |
| "I want a list of every `User` that has _only_ unpublished `Post` records"        | `every` post is unpublished         |

### Filter the relations list

> "Show me every Prisma employee's first post"

When you use `select` to return a subset of data from related records (for example, a user's posts), you can filter which related records should be returned. For example, you might want to query all users with a `prisma.io` email address and select the titles of their published posts.

#### Retrieve _all_ `User` records where `email` contains `prisma.io`, and select the `title` of all `Post` records that have not been published yet

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    Post: {
      where: {
        published: false,
      },
      select: {
        title: true,
      },
    },
  },
})
```

You can use the `post` model property to write the same query:

```js
const result = await prisma.post.findMany({
  where: {
    published: false,
    User: {
      email: {
        contains: 'prisma.io',
      },
    },
  },
  select: {
    title: true,
  },
})
```

## Fluent API

The fluent API lets you _fluently_ traverse the [relations](../prisma-schema/relations) of your models via function calls. Note that the _last_ function call determines the return type of the entire query (the respective type annotations are added in the code snippets below to make that explicit).

This query returns all `Post` records by a specific `User`:

```ts
const postsByUser: Post[] = await prisma.user
  .findUnique({ where: { email: 'alice@prisma.io' } })
  .posts()
```

Note that this call is equivalent to this Prisma Client query:

```ts
const postsByUser = await prisma.post.findMany({
  where: { author: { email: 'alice@prisma.io' } },
})
```

The main difference between the two is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this [GitHub issue](https://github.com/prisma/prisma/issues/1984)).

This request returns all categories by a specific post:

```ts
const categoriesOfPost: Category[] = await prisma.post.findUnique({ where: { id: 1 } }).categories()
```

Note that you can chain as many queries as you like. In this example, the chaining starts at `Profile` and goes over `User` to `Post`:

```ts
const posts: Post[] = await prisma.profile
    .findUnique({ where: { id: 1 } })
    .user()
    .posts()
}
```

The only requirement for chaining is that the previous function call must return only a _single object_ (e.g. as returned by a `findUnique` query or a "to-one relation" like `profile.user()`).

The following query is **not possible** because `findMany` does not return a single object but a _list_:

```ts
// This query is illegal
const posts = await prisma.user
    .findMany()
    .posts()
}
```
