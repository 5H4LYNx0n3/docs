---
title: 'CRUD'
metaTitle: 'CRUD (Reference)'
metaDescription: 'This page provides a detailed reference of the auto-generated CRUD queries that are exposed in the Prisma Client API, such as findOne, findMany, create, ...'
---

<TopBlock>

</TopBlock>

## Create 

### Create a single record

### Create multiple records

### Nested creates

## Read

### Get record by ID

## Update

## Delete


## delete

The `delete` query deletes an existing database record. Even though the record is being deleted, `delete` still returns the object that was deleted. You can use the `select` and `include` options to determine which properties should be included on the returned object.

### Options

#### Type

`delete` takes as input an object of the following type:

```ts
export type FindOneUserArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

These are further relevant generated types:

```ts
export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}
```

#### Reference

| Name      | Type                   | Required | Description                                                                      |
| --------- | ---------------------- | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput` | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                    |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object.       |

### Return type

`delete` returns a plain old JavaScript object or throws a `RecordNotFound` exception if the unique identifier does not exist:

```terminal
Error for binding '0': RecordNotFound("Record to delete does not exist.")
```

> **Tip**: If you need to delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)

The type of the object that's returned by a `delete` API call depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

**Delete the `User` record with an `id` of `1`**:

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

## updateMany

The `updateMany` query updates a batch of existing database records in bulk and returns the number of updated records. You can [filter](filtering) the list of records to be updated.

To perform arithmeic operations (add, subtract, multiply), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

### Options

#### Type

`updateMany` takes as input an object of the following type:

```ts
export type UserUpdateManyArgs = {
  data: UserUpdateManyMutationInput
  where?: UserWhereInput | null
}
```

These are further relevant generated types:

```ts
export type UserUpdateManyMutationInput = {
  id?: number | null
  name?: string | null
  email?: string | null
  role?: Role | null
  profileViews?: number | null
  coinflips?: UserUpdatecoinflipsInput | null
}

export type UserUpdatecoinflipsInput = {
  set?: Enumerable<boolean> | null
}

export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}
```

#### Reference

| Name    | Type                          | Required | Description                                                                                                                                                                                         |
| ------- | ----------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`  | `UserUpdateManyMutationInput` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`. |
| `where` | `UserWhereInput`              | No       | Wraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.                                                         |

### Return type

`updateMany` returns an object of type `BatchPayload`, which is defined as follows:

```ts
export type BatchPayload = {
  count: number
}
```

The value of `count` is an integer and represents the number of records that were updated.

### Examples

**Update all `User` records where the `name` is `Alice` to `ALICE`**:

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

## deleteMany

The `deleteMany` query deletes a batch of existing database records in bulk and returns the number of deleted records. You can [filter](filtering) the list of records to be deleted.

### Options

#### Type

`deleteMany` takes as input an object of the following type:

```ts
export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}
```

#### Reference

| Name    | Type             | Required | Description                                                                  |
| ------- | ---------------- | -------- | ---------------------------------------------------------------------------- |
| `where` | `UserWhereInput` | No       | Wraps _all_ fields of a model so that the list can be filtered by any field. |

### Return type

`deleteMany` returns an object of type `BatchPayload`, which is defined as follows:

```ts
export type BatchPayload = {
  count: number
}
```

The value of `count` is an integer and represents the number of records that were deleted.

### Examples

**Delete all `User` records where the `name` is `Alice`**:

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

## `count`

Use the `count()` method on any model property on your `PrismaClient` instance to return the number of available records. You can [filter](filtering) the list of records to be counted.

### Options

#### Type

`count` an object of the following type as input:

```ts
export type FindManyUserArgs = {
  where?: UserWhereInput | null
  orderBy?: Enumerable<UserOrderByInput> | null
  skip?: number | null
  after?: UserWhereUniqueInput | null
  before?: UserWhereUniqueInput | null
  first?: number | null
  last?: number | null
}
```

These are further relevant generated types:

```ts
export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}

export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}

export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}

export type UserOrderByInput = {
  id?: SortOrder | null
  name?: SortOrder | null
  email?: SortOrder | null
  role?: SortOrder | null
  profileViews?: SortOrder | null
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```

#### Reference

| Name      | Type                           | Required | Description                                                                                                 |
| --------- | ------------------------------ | -------- | ----------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`               | No       | Wraps _all_ fields of a model so that the list can be filtered by any model property.                       |
| `orderBy` | `Enumerable<UserOrderByInput>` | No       | Lets you order the returned list by any model property.                                                     |
| `skip`    | `string`                       | No       | Specifies how many of the returned objects in the list should be skipped.                                   |
| `after`   | `UserWhereUniqueInput`         | No       | Specifies the starting object for the list (the value typically specifies an `id` or another unique value). |
| `before`  | `UserWhereUniqueInput`         | No       | Specifies the last object for the list (the value typically specifies an `id` or another unique value).     |
| `first`   | `number`                       | No       | Specifies how many elements should be returned in the list (as seen from the _beginning_ of the list).      |
| `last`    | `number`                       | No       | Specifies how many elements should be returned in the list (as seen from the _end_ of the list).            |

### Return type

`count` returns an `number`:

```ts
export type BatchPayload = {
  count: number
}
```

### Examples

Count all `User` records:

```javascript
const result = await prisma.user.count()
```

Count all `User` records with at least one published `Post`:

```javascript
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

## Working with advanced scalar types

### Working with `Json` fields

See [Working with Json](working-with-json).

### Working with scalar lists / scalar arrays

The following example demonstrates how to set the value of a scalar list (`coinflips`) when you create a model:

```ts
const createdUser = await prisma.user.create({
  data: {
    email: 'eloise@prisma.io',
    coinflips: [true, true, true, false, true],
  },
})
```

Scalar lists only support setting a value - you cannot add or remove elements, only overwrite the entire value. The following example retrieves user, uses `push()` to add three new coin flips, and overwrites the `coinflips` property in an `update`:

```ts
const user = await prisma.user.findOne({
  where: {
    email: 'eloise@prisma.io',
  },
})

if (user) {
  console.log(user.coinflips)

  user.coinflips.push(true, true, false)

  const updatedUser = await prisma.user.update({
    where: {
      email: 'eloise@prisma.io',
    },
    data: {
      coinflips: user.coinflips,
    },
  })

  console.log(updatedUser.coinflips)
}
```

## Atomic operations on update

Atomic operations on update is available for `Float` and `Int` field types. This feature allows you to update a field based on its **current** value (such as _subtracting_ or _dividing_) without risking a race condition.

<details><summary>Overview: Race conditions</summary>

A race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:

| Client   | Operation           | Value  |
| :------- | :------------------ | :----- |
| Client 1 | **Get** field value | `21`   |
| Client 2 | **Get** field value | `21`   |
| Client 2 | **Set** field value | `22`   |
| Client 1 | **Set** field value | `22` ✘ |

The value _should_ be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:

| Client   | Operation                   | Value              |
| :------- | :-------------------------- | :----------------- |
| Client 1 | **Get and set** field value | `21` &rarr; `22`   |
| Client 2 | **Get and set** field value | `22` &rarr; `23` ✔ |

</details>

### Reference

| Option      | Description                                                   |
| :---------- | :------------------------------------------------------------ |
| `increment` | Adds `n` to the current value.                                |
| `decrement` | Subtacts `n` from the current value.                          |
| `multiply`  | Multiplies the current value by `n`.                          |
| `divide`    | Divides the current value by `n`.                             |
| `set`       | Sets the current field value. Identical to `{ myField : n }`. |

> **Note**: You can only perform **one** atomic update per field, per query.

`Int` and `Float` fields accept objects with the following type as input:

```ts
export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

#### Examples

##### Increment all `view` and `likes` fields of all `Post` records by `1`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1,
    },
    likes: {
      increment: 1,
    },
  },
})
```

##### Set all `count` fields of all `Post` records to `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0,
    },
  },
})
```

Can also be written as:

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  },
})
```
